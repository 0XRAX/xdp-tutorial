# -*- fill-column: 76; -*-
#+TITLE: Tutorial: Basic03
#+OPTIONS: ^:nil

In this lesson you will learn about BPF-maps, and in the assignment get
hands-on experience with extending the "value" size/content, and reading the
contents from userspace.

We will only cover two simple maps types:
 - =BPF_MAP_TYPE_ARRAY= and
 - =BPF_MAP_TYPE_PERCPU_ARRAY=.

* Lesson

** Lesson#1: defining a map

Creating a BPF-map is done by defining a global struct =bpf_map_def= (in
[[file:xdp_prog_kern.c]]), with a special =SEC("maps")= as below:

#+begin_src C
struct bpf_map_def SEC("maps") xdp_stats_map = {
	.type        = BPF_MAP_TYPE_ARRAY,
	.key_size    = sizeof(__u32),
	.value_size  = sizeof(struct datarec),
	.max_entries = XDP_ACTION_MAX,
};
#+end_src

BPF-maps are basically a generic *key-value* stores (see =key_size= and
=value_size=), with a given =type=, and maximum allowed entries
=max_entries=. Here we focus on the simple =BPF_MAP_TYPE_ARRAY=, which means
=max_entries= gets allocated when map is created.

The BPF-map is both accessible from BPF-prog (kernel) side and userspace.
How this is done and how they differ is part of this lesson.

** Lesson#2: libbpf map ELF relocation

The libbpf library (fortunately) handles ELF-object decoding and map
references relocation, when the map is referenced from the BPF code.

It is worth pointing out that everything goes through the bpf-syscall. This
means that libbpf /must/ create the maps and programs with separate
invocations of the bpf-syscall. Then how can a BPF-prog reference a BPF-map?
This happen via first loading all the BPF-maps, and get back their
corresponding file-descriptor (FD). Then the ELF-relocation table is used
for identifying when the BPF-prog reference a given map, and then rewrite
those BPF-byte-code instructions to use the map FD, before loading BPF-prog
into the kernel.

** Lesson#3: bpf_object to bpf_map

As you learned in [[file:../basic02-prog-by-name/][basic02]] the libbpf API have "objects" and functions
working on/with these objects. The struct =bpf_object= represents ELF object
itself (which is returned from our =load_bpf_and_xdp_attach()= function).

In our function find_map_fd() (in [[file:xdp_load_and_stats.c]]) the function
=bpf_object__find_map_by_name()= is used for finding the =bpf_map= object
with a given name. (Note, the length of the map name is provided by ELF and
is longer than what the name kernel stores, after loading it). Next step is
obtaining the map file-descriptor (FD) via =bpf_map__fd()=. There is also a
libbpf function that wrap these two steps, which is called
=bpf_object__find_map_fd_by_name()=.

** Lesson#4: read map-value from userspace

The contents of the map is read from userspace via the function
=bpf_map_lookup_elem()=, which is a simple syscall-wrapper, that operate on
the map file-descriptor (FD), lookup the =key= and store the value into the
memory area supplied by the value pointer. It is userspace own
responsibility to known what map it is reading and know the value size, and
thus have allocated memory large enough to store the value. In our example
we demonstrate how userspace can query the map-FD and get back some info in
struct =bpf_map_info= via syscall-wrapper =bpf_obj_get_info_by_fd()=.

The program =xdp_load_and_stats= will periodically read the xdp_stats_map
value and produce some stats.


* Assignments

The assignments are have "hint" marks in the code via =Assignment#num=
comments.

** Assignment#1: Add bytes counter

The current assignment code only counts packets.  It is your *assignment* to
extend this to also count bytes.

Notice how BPF-map =xdp_stats_map= used:
 - =.value_size = sizeof(struct datarec)=

The BPF-map have no knowledge about the data-structure used for the value
record, it only knows the size. (The [[https://github.com/torvalds/linux/blob/master/Documentation/bpf/btf.rst][BPF Type Format]] ([[https://www.kernel.org/doc/html/latest/bpf/btf.html][BTF]]) is an advanced
topic, that allow for associating data-struct knowledge via debug info, but
we ignore that for now). Thus, it is up-to the two-sides (userspace and
BPF-prog kernel side) to stay in-sync on the content and structure of
=value=. The hint here on the data-structure used comes from =sizeof(struct
datarec)=, which indicate that =struct datarec= is used.

This =struct datarec= is defined in the include [[file:common_kern_user.h]] as:

#+begin_src C
/* This is the data record stored in the map */
struct datarec {
	__u64 rx_packets;
	/* Assignment#1: Add byte counters */
};
#+end_src

*** Assignment#1.1: Update BPF-prog

Next step is update BPF-prog kernel side program: [[file:xdp_prog_kern.c]].

To figure out the length of the packet, you need to learn about the context
variable =*ctx= with type [[https://elixir.bootlin.com/linux/v5.0/ident/xdp_md][=struct xdp_md=]] that the BPF-prog gets a pointer
to, when invoked by the kernel. This =struct xdp_md= is a little odd, as all
members have type =__u32=, which is not actually their real data-types, as
access to this data-structure is remapped by the kernel at BPF-load time
(the BPF-byte-code instructions are rewritten by [[https://elixir.bootlin.com/linux/latest/ident/xdp_convert_ctx_access][=xdp_convert_ctx_access()=]]
and [[https://elixir.bootlin.com/linux/latest/ident/xdp_is_valid_access][=xdp_is_valid_access()=]] assign types for the verifier).  Access gets
remapped to struct =xdp_buff= and also struct =xdp_rxq_info=.

#+begin_src C
struct xdp_md {
	// (Note: type __u32 is NOT the real-type)
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	/* Below access go through struct xdp_rxq_info */
	__u32 ingress_ifindex; /* rxq->dev->ifindex */
	__u32 rx_queue_index;  /* rxq->queue_index */
};
#+end_src

First order of business in [[file:xdp_prog_kern.c]], is type-cast the data_end
and data into void pointers:

#+begin_src C
	void *data_end = (void *)(long)ctx->data_end;
	void *data     = (void *)(long)ctx->data;
#+end_src

Next step is calculating the number of bytes, by simply subtracting =data=
from =data_end=, and update the datarec member.

#+begin_src C
	__u64 bytes = data_end - data; /* Calculate packet length */
	lock_xadd(&rec->rx_bytes, bytes);
#+end_src

** Assignment#2: Handle other XDP actions stats

** Assignment#3: Per CPU stats

Avoid the atomic stats counter, by using another per-CPU array type, and
move the burden of summing to userspace.
