# -*- fill-column: 76; -*-
#+TITLE: Tutorial: Basic03
#+OPTIONS: ^:nil

In this lesson you will learn about BPF-maps, and in the assignment get
hands-on experience with extending the "value" size/content, and reading the
contents from userspace.

We will only cover two simple maps types:
 - =BPF_MAP_TYPE_ARRAY= and
 - =BPF_MAP_TYPE_PERCPU_ARRAY=.

* Lesson

** Lesson#1: defining a map

Creating a BPF-map is done by defining a global struct =bpf_map_def= (in
[[file:xdp_prog_kern.c]]), with a special =SEC("maps")= as below:

#+begin_src C
struct bpf_map_def SEC("maps") xdp_stats_map = {
	.type        = BPF_MAP_TYPE_ARRAY,
	.key_size    = sizeof(__u32),
	.value_size  = sizeof(struct datarec),
	.max_entries = XDP_ACTION_MAX,
};
#+end_src

BPF-maps are basically a generic *key-value* stores (see =key_size= and
=value_size=), with a given =type=, and maximum allowed entries
=max_entries=. Here we focus on the simple =BPF_MAP_TYPE_ARRAY=, which means
=max_entries= gets allocated when map is created.

The BPF-map is both accessible from BPF-prog (kernel) side and userspace.
How this is done and how they differ is part of this lesson.

** Lesson#2: libbpf map ELF relocation

The libbpf library (fortunately) handles ELF-object decoding and map
references relocation, when the map is referenced from the BPF code.

It is worth pointing out that everything goes through the bpf-syscall. This
means that libbpf /must/ create the maps and programs with separate
invocations of the bpf-syscall. Then how can a BPF-prog reference a BPF-map?
This happen via first loading all the BPF-maps, and get back their
corresponding file-descriptor (FD). Then the ELF-relocation table is used
for identifying when the BPF-prog reference a given map, and then rewrite
those BPF-byte-code instructions to use the map FD, before loading BPF-prog
into the kernel.



* Assignments

The assignments are have "hint" marks in the code via =Assignment#num=
comments.

** Assignment#1: Add byte counters

** Assignment#2: Handle other XDP actions stats

** Assignment#3: Per CPU stats

Avoid the atomic stats counter, by using another per-CPU array type, and
move the burden of summing to userspace.
