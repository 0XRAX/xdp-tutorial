# -*- fill-column: 76; -*-
#+TITLE: Tutorial: Basic04
#+OPTIONS: ^:nil

In this lesson you will learn about reading BPF-maps from another "external"
program.

In basic03 the [[file:../basic03-map-counter/xdp_load_and_stats.c][xdp_load_and_stats.c]] program were both doing BPF/XDP-loading
and reading stats from the map. This was practical as the map
file-descriptor was readily available. In this lesson this program have been
split into two separate programs:
 - one focused on BPF/XDP-loading ([[file:xdp_loader.c]]) and
 - one focused on reading and printing stats ([[file:xdp_stats.c]]).

The basic quest revolves around how to share or obtain the UNIX
file-descriptor to the BPF-map, that we want to read from. Access to a
BPF_map still goes through the BPF-syscall, but the handle is a standard
UNIX file-descriptor.

* Overview of exercise                                                  :TOC:
- [[#solutions-to-basic03-assignments][Solutions to basic03 assignments]]
- [[#lessons][Lessons]]
  - [[#lesson1-bpf-syscall-wrappers][Lesson#1: bpf-syscall wrappers]]
  - [[#lesson2-mount-bpf-file-system][Lesson#2: mount BPF file-system]]
  - [[#lesson3-gotchas-with-pinned-maps][Lesson#3: gotchas with pinned maps]]

* Solutions to basic03 assignments

The assignments in [[file:../basic03-map-counter][basic03]] have been "solved" or implemented in this basic04
lesson. Thus, this functions as the reference solution for basic03.

* Lessons

** Lesson#1: bpf-syscall wrappers

When splitting up the [[file:../basic03-map-counter/xdp_load_and_stats.c][xdp_load_and_stats.c]] program, into [[file:xdp_loader.c]]
and [[file:xdp_stats.c]], notice that xdp_stats.c no-longer =#include
<bpf/libbpf.h>=. This is because xdp_stats doesn't use any of the advanced
libbpf "object" related functions, it only use the basis bpf-syscall
wrappers, which libbpf also provides.

The bpf-syscall wrappers are provided by libbpf via =#include <bpf/bpf.h>=,
which for this build-setup gets installed in =../libbpf/src/root/usr/include/bpf/bpf.h=
(link to source [[https://github.com/libbpf/libbpf/blob/master/src/bpf.h][bpf.h]] in libbpf-github repo).

The point there is that libbpf keep the low-level bpf-syscall wrappers in
separate files [[https://github.com/libbpf/libbpf/blob/master/src/bpf.h][bpf.h]] and [[https://github.com/libbpf/libbpf/blob/master/src/bpf.c][bpf.c]]. We could create a smaller binary by not
linking with libbpf.a, but for ease of use, the proper library is used.

** Lesson#2: mount BPF file-system

Pinning BPF-map means creating files for-each map under a special mount
point =/sys/fs/bpf/=. This mount point use a "BPF file-system" type. The
pinning will fail of this is not mounted under =/sys/fs/bpf/=.

The needed mount command is:
#+begin_example
 mount -t bpf bpf /sys/fs/bpf/
#+end_example

If you followed the tutorial you will likely already have gotten this
mounted without noticing. As both iproute2 'ip' and our [[file:../testenv][testenv]] will
automatically mount it to the default location under =/sys/fs/bpf/=.
If not, use the above command to mount it.

** Lesson#3: gotchas with pinned maps

Pinning all maps in a =bpf_object= using libbpf is easily done with:
=bpf_object__pin_maps(bpf_object, pin_dir)=.

To avoid filename collisions, when loading several XDP program on different
interfaces, the maps are export/pinned under a sub-directory with the
interface name, that was specified via =--dev=. The libbpf
=bpf_object__pin_maps()= call even handle creating this sub-directory (via
mkdir(3)).

Open [[file:xdp_loader.c]] and look at our function =pin_maps_in_bpf_object()=,
and you will see that due to corner-case it is slightly more complicated.
E.g. need to handle cleanup of previous XDP progs that not have cleaned up
their maps, which we choose to do via =bpf_object__unpin_maps()=. If this is
the first usage, then we should not try to "unpin maps" as that will fail.
We currently don't handle the corner case, where our BPF-prog get extended
with a new-map, and then want to replace an existing BPF-prog that doesn't
contain this new-map, which will result in =bpf_object__unpin_maps()= not
finding the new-map to unlink, and then fails.

In this solution we create new maps and delete the old ones. This is a
design choice as it is easier and also makes it easier that the counters
reset to zero for observe if our program works. But one can easily imagine
that for real applications it could be a problem that the counters reset to
zero for the stats tools.






